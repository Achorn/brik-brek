{"version":3,"file":"index-OzDcCG5h.js","sources":["../../src/app.js"],"sourcesContent":["const canvasWidth = 700;\nconst canvasHeight = 700;\nlet cursorPosX = canvasWidth / 2;\n//COLORS\nconst lightPink = \"#f0dede\";\nconst darkPink = \"#cf3673\";\nconst greyBlue = \"#748cbb\";\n\nconst titleElement = document.querySelector(\"#title-container\");\nconst gameOverElement = document.querySelector(\"#game-over\");\nconst gameOverTitleElement = document.querySelector(\"#game-over-title\");\nconst scoreElement = document.querySelector(\"#score\");\nconst livesElement = document.querySelector(\"#lives\");\n\nconst levelElement = document.querySelector(\"#level\");\n\nlet score = 0;\nlet lives = 3;\nlet level = 1;\nlet gamePad = { up: false, left: false, right: false, reset: false };\nlet paddingTop = 65;\nlet canvas = document.querySelector(\"#my-canvas\");\nlet ctx = canvas.getContext(\"2d\");\nlet balls = [];\nlet ballSpeed = 0.45;\nlet blocks = [];\n// start, playing, pause game over\nlet state = \"START\";\n\n//create Level of Blocks\n\nlet blockGroup = {\n  entering: false,\n  Offset: 0,\n};\nlet updateBlockGroup = (deltaTime) => {\n  // update offset\n  if (blockGroup.entering) {\n    if (blockGroup.Offset < 0) {\n      let moveDistance = deltaTime * 0.4;\n      blockGroup.Offset += moveDistance;\n      blocks.forEach((block) => {\n        if (block.id != \"paddle\") {\n          block.startY = block.startY + moveDistance;\n        }\n      });\n    } else blockGroup.entering = false;\n  }\n  // update blocks y\n};\nconst createBlocks = () => {\n  //randomly select powerups\n\n  for (let i = 0; i < 5; i++) {\n    for (let j = 0; j < 5; j++) {\n      let randomNum = Math.random();\n      let color =\n        randomNum < 0.333333\n          ? darkPink\n          : randomNum < 0.66666\n          ? \"#855c8c\"\n          : greyBlue;\n      blocks.push({\n        startX: 25 + i * 140,\n        startY: paddingTop + j * 50 + blockGroup.Offset,\n        width: 100,\n        height: 30,\n        toDispose: false,\n        id: i + j,\n        color: color,\n        power: \"ball\",\n      });\n    }\n  }\n};\ncreateBlocks();\nlet centerOfBlock = (block) => {\n  return {\n    x: block.startX + block.width * 0.5,\n    y: block.startY + block.height * 0.5,\n  };\n};\nlet drawBlocks = () => {\n  blocks.forEach((block) => {\n    // calculateCollisionSide(block);\n    ctx.fillStyle = block.color;\n    ctx.fillRect(block.startX, block.startY, block.width, block.height);\n  });\n};\nlet activateBlockPower = (block) => {\n  if (!block.power) return;\n  if (level != 1) return;\n  let blockCenter = centerOfBlock(block);\n  let ball = {\n    radius: 15,\n    positionX: blockCenter.x,\n    positionY: blockCenter.y,\n    xDirection: 1,\n    yDirection: 1,\n    speed: ballSpeed,\n    color: block.color,\n    life: 1,\n    toDispose: false,\n  };\n  balls.push(ball);\n};\n// ctx.clearRect(45, 45, 60, 60);\n// ctx.strokeRect(50, 50, 50, 50);\n\nlet paddle = {\n  startX: canvas.width * 0.5 - 150 * 0.5,\n  startY: canvas.height - 50,\n  width: 150,\n  height: 20,\n  toDispose: false,\n  color: greyBlue,\n  id: \"paddle\",\n};\nblocks.push(paddle);\n\n// const drawPaddle = () => {\n//   ctx.fillStyle = paddle.color;\n//   //   ctx.fillRect(\n//   //     paddle.startX - paddle.width * 0.5,\n//   //     canvas.height - 20 - 20,\n//   //     paddle.width,\n//   //     paddle.height\n//   //   );\n// };\n\nconst updatePaddle = (deltaTime) => {\n  let direction = 0;\n  if (gamePad.left) direction -= 0.5 * deltaTime;\n  if (gamePad.right) direction += 0.5 * deltaTime;\n\n  paddle.startX = paddle.startX + direction;\n  if (paddle.startX <= 0) paddle.startX = 5;\n  if (paddle.startX + paddle.width >= canvas.width)\n    paddle.startX = canvas.width - paddle.width - 5;\n\n  //find cursor position. and move it to there...\n};\n\nlet primaryBall = {\n  radius: 15,\n  positionX: canvas.width / 2,\n  positionY: canvas.width / 2,\n  xDirection: 0,\n  yDirection: -1,\n  speed: ballSpeed,\n  color: \"white\",\n  life: 1,\n  toDispose: false,\n};\nprimaryBall.positionY = canvas.height - 80;\n\nballs.push(primaryBall);\n\nlet updateBalls = (deltaTime) => {\n  if (state == \"START\") {\n    //update primary ball\n    balls[0].positionX = paddle.startX + paddle.width * 0.5;\n    balls[0].positionY = paddle.startY - 30;\n  } else {\n    balls.forEach((ball) => updateBall(ball, deltaTime));\n  }\n};\nlet updateBall = (ball, deltaTime) => {\n  ball.positionX += ball.speed * deltaTime * ball.xDirection;\n  ball.positionY += ball.speed * deltaTime * ball.yDirection;\n  // if (ball.positionY + ball.radius >= canvas.height) ball.yDirection = -1;\n  if (ball.positionY - ball.radius <= 0)\n    ball.yDirection = Math.abs(ball.yDirection);\n  if (ball.positionX + ball.radius >= canvas.width)\n    ball.xDirection = -Math.abs(ball.xDirection);\n  if (ball.positionX - ball.radius <= 0)\n    ball.xDirection = Math.abs(ball.xDirection);\n\n  //out of bounds\n  if (ball.positionY - ball.radius > canvas.height) {\n    ball.toDispose = true;\n  }\n};\n\nlet drawBalls = () => {\n  balls.forEach((ball) => drawBall(ball));\n};\nlet drawBall = (ball) => {\n  ctx.beginPath();\n  ctx.arc(ball.positionX, ball.positionY, ball.radius, 0, 2 * Math.PI);\n  ctx.fillStyle = ball.color;\n  ctx.fill();\n  // ctx.stroke();\n};\nconst disposeBalls = () => {\n  balls = balls.filter((ball) => !ball.toDispose);\n};\n\nconst checkCollision = () => {\n  //have ball\n  // check every block to see if it is colliding with ball\n  blocks.forEach((block) => {\n    balls.forEach((ball) => {\n      if (isColliding(block, ball)) {\n        let side = calculateCollisionSide(block, ball);\n        if (side == 1) ball.yDirection = 1; //bottom\n        if (side == 2) ball.xDirection = -1; //left\n        if (side == 3) ball.xDirection = 1; //right\n        if (side == 4) ball.yDirection = -1; //top\n        if (block.id != \"paddle\") {\n          activateBlockPower(block);\n          block.toDispose = true;\n          score += 50;\n        } else {\n          //calculate ball angle hitting paddle\n\n          let blockSurface = {\n            start: block.startX,\n            end: block.startX + block.width,\n            center: block.startX + block.width * 0.5,\n          };\n          let frac = ball.positionX - blockSurface.start;\n          let center = blockSurface.center - blockSurface.start;\n          let angle = (frac - center) / block.width;\n          let distanceFromCenter = (frac - center) / block.width;\n          distanceFromCenter = Math.max(-0.3, distanceFromCenter);\n          distanceFromCenter = Math.min(0.3, distanceFromCenter);\n          distanceFromCenter *= 2;\n\n          distanceFromCenter *= 90;\n          distanceFromCenter <= 0\n            ? (distanceFromCenter += 90)\n            : (distanceFromCenter -= 90);\n          // distanceFromCenter = -distanceFromCenter;\n\n          // ball position\n          // convert to angle from 0-180\n          // angle = 180 - (distanceFromCenter + 0.5) * 180;\n          let direction = distanceFromCenter <= 0 ? 1 : -1;\n          let alpha = Math.abs(distanceFromCenter);\n          let c = 1;\n          const alphaRad = (alpha * Math.PI) / 180;\n\n          // Calculate side a\n          const a = c * Math.sin(alphaRad);\n\n          // Calculate side b\n          const b = c * Math.cos(alphaRad);\n\n          // paddle position\n          // normalize or whatever\n          // generate angle with window of tolerance\n          ball.xDirection = b * direction;\n          ball.yDirection = -a;\n        }\n        // ball.speed += 0.005;\n      }\n    });\n  });\n};\nconst isColliding = (block, ball) => {\n  //X intersecting\n  // # Find the closest point on the square\n  let blockCenter = centerOfBlock(block);\n  let blockX = blockCenter.x;\n  let blockY = blockCenter.y;\n  let diff_x = ball.positionX - blockX;\n  let diff_y = ball.positionY - block.startY;\n\n  let closest_x =\n    blockX + Math.max(Math.min(diff_x, block.width / 2), -block.width / 2);\n  let closest_y =\n    blockY + Math.max(Math.min(diff_y, block.height / 2), -block.height / 2);\n\n  // # Calculate the distance\n  let distance = Math.sqrt(\n    (ball.positionX - closest_x) ** 2 + (ball.positionY - closest_y) ** 2\n  );\n  // # Check for collision\n  return distance <= ball.radius;\n};\nconst calculateCollisionSide = (block, ball) => {\n  //lower quadrent\n  // between angle from center of block to lower left angle to andle of block to lower right angle\n  let blockCenter = {\n    x: block.startX + block.width * 0.5,\n    y: block.startY + block.height * 0.5,\n  };\n  let ballAngle = Math.atan2(\n    blockCenter.x - ball.positionX,\n    blockCenter.y - ball.positionY\n  );\n\n  let bottomLeftPosition = { x: block.startX, y: block.startY + block.height };\n  let bottomRightPosition = {\n    x: block.startX + block.width,\n    y: block.startY + block.height,\n  };\n\n  let topLeftPosition = { x: block.startX, y: block.startY };\n  let topRightPosition = {\n    x: block.startX + block.width,\n    y: block.startY,\n  };\n\n  let bottomLeftAngle = Math.atan2(\n    blockCenter.x - bottomLeftPosition.x,\n    blockCenter.y - bottomLeftPosition.y\n  );\n\n  let bottomRightAngle = Math.atan2(\n    blockCenter.x - bottomRightPosition.x,\n    blockCenter.y - bottomRightPosition.y\n  );\n\n  let topLefttAngle = Math.atan2(\n    blockCenter.x - topLeftPosition.x,\n    blockCenter.y - topLeftPosition.y\n  );\n\n  let topRightAngle = Math.atan2(\n    blockCenter.x - topRightPosition.x,\n    blockCenter.y - topRightPosition.y\n  );\n  let angle = 4;\n\n  if (ballAngle > bottomLeftAngle || ballAngle < bottomRightAngle) {\n    // Bottom\n    angle = 1;\n    // block.color = greyBlue;\n  } else if (ballAngle > topLefttAngle && ballAngle < bottomLeftAngle) {\n    // Left\n    angle = 2;\n    // block.color = darkPink;\n  } else if (ballAngle > bottomRightAngle && ballAngle < topRightAngle) {\n    // Right\n    angle = 3;\n    // block.color = darkPink;\n  } else {\n    // Top\n    // block.color = greyBlue;\n  }\n  return angle;\n};\ndocument.addEventListener(\"keydown\", (e) => {\n  if (e.code === \"ArrowLeft\") {\n    gamePad.left = true;\n  }\n  if (e.code === \"ArrowRight\") {\n    gamePad.right = true;\n  }\n  if (e.code === \"ArrowUp\") {\n    if (state === \"START\") state = \"PLAYING\";\n    gamePad.up = true;\n  }\n  if (e.code === \"KeyR\") {\n    gamePad.reset = true;\n  }\n});\ndocument.addEventListener(\"keyup\", (e) => {\n  if (e.code === \"ArrowLeft\") {\n    gamePad.left = false;\n  }\n  if (e.code === \"ArrowRight\") {\n    gamePad.right = false;\n  }\n  if (e.code === \"ArrowUp\") {\n    gamePad.up = false;\n  }\n\n  if (e.code === \"KeyR\") {\n    gamePad.reset = false;\n  }\n});\n\n// canvas.addEventListener(\"mousemove\", (event) => {\n//   const rect = canvas.getBoundingClientRect(); // Get canvas position relative to viewport\n//   const x = event.clientX - rect.left; // Calculate mouse position relative to canvas\n//   cursorPosX = x - paddle.width * 0.5;\n//   const y = event.clientY - rect.top;\n// });\nconst disposeBlocks = () => {\n  blocks = blocks.filter((block) => !block.toDispose);\n};\nconst updateScore = () => {\n  scoreElement.innerHTML = score;\n};\n\n// const element = document.getElementById(\"yourElement\");\n// let startX, startY;\n\n// document.addEventListener(\"touchstart\", (e) => {\n//   console.log(\"start\");\n//   startX = e.touches[0].clientX;\n//   startY = e.touches[0].clientY;\n//   console.log(startX, startY);\n// });\n\n// document.addEventListener(\"touchmove\", (e) => {\n//   const currentX = e.touches[0].clientX;\n//   const currentY = e.touches[0].clientY;\n\n//   const deltaX = currentX - startX;\n//   const deltaY = currentY - startY;\n//   console.log(currentX, currentY);\n//   // Perform actions based on the drag\n//   // For example, move the element:\n//   // element.style.transform = `translate(${deltaX}px, ${deltaY}px)`;\n// });\n\n// document.addEventListener(\"touchend\", (e) => {\n//   // Actions after drag is completed\n//   // Reset start positions\n//   console.log(\"end\");\n//   startX = 0;\n//   startY = 0;\n// });\n\nlet lastTime = 16;\nlet gameLoop = (currentTime) => {\n  // Calculate deltaTime in milliseconds\n  const deltaTime = currentTime - lastTime;\n\n  if (deltaTime) {\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    checkCollision();\n\n    updatePaddle(deltaTime);\n    updateBlockGroup(deltaTime);\n    updateBalls(deltaTime);\n    if (state == \"PLAYING\") {\n      titleElement.style.display = \"none\";\n\n      disposeBlocks();\n      disposeBalls();\n\n      if (blocks.length == 1) {\n        // NEXT LEVEL\n        level = level + 1;\n        blockGroup.entering = true;\n        blockGroup.Offset = -400;\n        console.log(\"next level\");\n        levelElement.innerHTML = level;\n        createBlocks();\n        // gameOverElement.style.display = \"flex\";\n      }\n      if (balls.length == 0) {\n        if (lives === 0) {\n          state = \"OVER\";\n          gameOverElement.style.display = \"flex\";\n        } else {\n          state = \"START\";\n          lives -= 1;\n          livesElement.innerHTML = lives;\n          balls.push({\n            radius: 15,\n            positionX: paddle.startX + paddle.width * 0.5,\n            positionY: paddle.startY - 30,\n            xDirection: 0,\n            yDirection: -1,\n            speed: ballSpeed,\n            color: \"white\",\n            life: 1,\n            toDispose: false,\n          });\n        }\n      }\n    }\n    if (state == \"OVER\") {\n      if (gamePad.reset) location.reload();\n    }\n\n    // drawPaddle();\n    drawBlocks();\n    drawBalls();\n    updateScore();\n    // Store the current time for the next frame\n    lastTime = currentTime;\n  }\n  requestAnimationFrame(gameLoop);\n};\n\ngameLoop();\n"],"names":["darkPink","greyBlue","titleElement","gameOverElement","scoreElement","livesElement","levelElement","score","lives","level","gamePad","paddingTop","canvas","ctx","balls","ballSpeed","blocks","state","blockGroup","updateBlockGroup","deltaTime","moveDistance","block","createBlocks","i","j","randomNum","color","centerOfBlock","drawBlocks","activateBlockPower","blockCenter","ball","paddle","updatePaddle","direction","primaryBall","updateBalls","updateBall","drawBalls","drawBall","disposeBalls","checkCollision","isColliding","side","calculateCollisionSide","blockSurface","frac","center","distanceFromCenter","alpha","c","alphaRad","a","b","blockX","blockY","diff_x","diff_y","closest_x","closest_y","ballAngle","bottomLeftPosition","bottomRightPosition","topLeftPosition","topRightPosition","bottomLeftAngle","bottomRightAngle","topLefttAngle","topRightAngle","angle","e","disposeBlocks","updateScore","lastTime","gameLoop","currentTime"],"mappings":"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"}