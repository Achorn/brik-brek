{"version":3,"file":"index-BCIsqd7w.js","sources":["../../src/app.js"],"sourcesContent":["const canvasWidth = 700;\nconst canvasHeight = 700;\nlet cursorPosX = canvasWidth / 2;\n//COLORS\nconst lightPink = \"#f0dede\";\nconst darkPink = \"#cf3673\";\nconst greyBlue = \"#748cbb\";\n\nconst titleElement = document.querySelector(\"#title-container\");\nconst gameOverElement = document.querySelector(\"#game-over\");\nconst gameOverTitleElement = document.querySelector(\"#game-over-title\");\nconst scoreElement = document.querySelector(\"#score\");\nconst livesElement = document.querySelector(\"#lives\");\nconst levelElement = document.querySelector(\"#level\");\n\nlet score = 0;\nlet lives = 3;\nlet level = 1;\nlet gamePad = { up: false, left: false, right: false, reset: false };\nlet paddingTop = 65;\nlet canvas = document.querySelector(\"#my-canvas\");\nlet ctx = canvas.getContext(\"2d\");\nlet balls = [];\nlet ballSpeed = 0.45;\nlet powerSpeed = 1;\nlet blocks = [];\nlet powerups = [];\n// start, playing, pause game over\nlet state = \"START\";\n\n//create Level of Blocks\n\nlet blockGroup = {\n  entering: false,\n  Offset: 0,\n};\nlet updateBlockGroup = (deltaTime) => {\n  // update offset\n  if (blockGroup.entering) {\n    if (blockGroup.Offset < 0) {\n      let moveDistance = deltaTime * 0.4;\n      blockGroup.Offset += moveDistance;\n      blocks.forEach((block) => {\n        if (block.id != \"paddle\") {\n          block.startY = block.startY + moveDistance;\n        }\n      });\n    } else blockGroup.entering = false;\n  }\n};\nconst createBlocks = () => {\n  //randomly select powerups\n  for (let i = 0; i < 5; i++) {\n    for (let j = 0; j < 4; j++) {\n      let randomNum = Math.random();\n      let powerNum = Math.random();\n      // let powerNum = 0.75;\n      let color =\n        randomNum < 0.333333\n          ? darkPink\n          : randomNum < 0.66666\n          ? \"#855c8c\"\n          : greyBlue;\n      blocks.push({\n        startX: 25 + i * 140,\n        startY: paddingTop + j * 50 + blockGroup.Offset,\n        width: 100,\n        height: 30,\n        toDispose: false,\n        id: i + j,\n        color: color,\n        power:\n          powerNum > 0.8\n            ? \"ball\"\n            : powerNum > 0.7\n            ? \"speed\"\n            : powerNum > 0.6\n            ? \"paddle\"\n            : \"\",\n      });\n    }\n  }\n};\ncreateBlocks();\nlet centerOfBlock = (block) => {\n  return {\n    x: block.startX + block.width * 0.5,\n    y: block.startY + block.height * 0.5,\n  };\n};\nlet drawBlocks = () => {\n  blocks.forEach((block) => {\n    ctx.fillStyle = block.color;\n    ctx.fillRect(block.startX, block.startY, block.width, block.height);\n    if (block.power) {\n      if (block.power == \"ball\") {\n        ctx.beginPath();\n        ctx.arc(\n          block.startX + block.width * 0.5,\n          block.startY + block.height * 0.5,\n          block.height * 0.3,\n          0,\n          2 * Math.PI\n        );\n        ctx.fillStyle = lightPink;\n        ctx.fill();\n      }\n      if (block.power == \"speed\") {\n        let triangleWidth = block.height * 0.3;\n        ctx.beginPath();\n        ctx.beginPath();\n        //point\n        ctx.moveTo(\n          block.startX - block.width * 0.5 + triangleWidth + block.width - 3,\n          block.startY + block.height * 0.5\n        );\n        //topLeft\n        ctx.lineTo(\n          block.startX + block.width * 0.5 - triangleWidth,\n          block.startY + block.height * 0.5 - triangleWidth\n        );\n\n        //bottomLeft\n        ctx.lineTo(\n          block.startX + block.width * 0.5 - triangleWidth,\n          block.startY + block.height * 0.5 + triangleWidth\n        );\n\n        ctx.fillStyle = lightPink;\n        ctx.fill();\n      }\n      if (block.power == \"paddle\") {\n        ctx.fillStyle = block.color;\n        ctx.fillStyle = lightPink;\n        ctx.fillRect(\n          block.startX + 25,\n          block.startY + 10,\n          block.width - 50,\n          block.height - 20\n        );\n        ctx.fill();\n      }\n    }\n  });\n};\nlet activateBlockPower = (block) => {\n  if (!block.power) return;\n  // if (level != 1) return;\n  if (block.power == \"ball\") {\n    let blockCenter = centerOfBlock(block);\n    let ball = {\n      radius: 15,\n      positionX: blockCenter.x,\n      positionY: blockCenter.y,\n      xDirection: 1,\n      yDirection: -1,\n      speed: ballSpeed,\n      color: block.color,\n      life: 1,\n      toDispose: false,\n    };\n    balls.push(ball);\n  }\n  if (block.power == \"speed\") {\n    powerups.push(new BallSpeedPowerUp());\n  }\n  if (block.power == \"paddle\") {\n    powerups.push(new PaddleGrowPowerUp());\n  }\n};\n// ctx.clearRect(45, 45, 60, 60);\n// ctx.strokeRect(50, 50, 50, 50);\n\nlet paddle = {\n  startX: canvas.width * 0.5 - 150 * 0.5,\n  startY: canvas.height - 50,\n  width: 150,\n  height: 20,\n  toDispose: false,\n  color: greyBlue,\n  id: \"paddle\",\n};\nblocks.push(paddle);\n\n// const drawPaddle = () => {\n//   ctx.fillStyle = paddle.color;\n//   //   ctx.fillRect(\n//   //     paddle.startX - paddle.width * 0.5,\n//   //     canvas.height - 20 - 20,\n//   //     paddle.width,\n//   //     paddle.height\n//   //   );\n// };\n\nconst updatePaddle = (deltaTime) => {\n  let direction = 0;\n  if (gamePad.left) direction -= 0.5 * deltaTime;\n  if (gamePad.right) direction += 0.5 * deltaTime;\n\n  paddle.startX = paddle.startX + direction;\n  if (paddle.startX <= 0) paddle.startX = 5;\n  if (paddle.startX + paddle.width >= canvas.width)\n    paddle.startX = canvas.width - paddle.width - 5;\n\n  //find cursor position. and move it to there...\n};\n\nlet primaryBall = {\n  radius: 15,\n  positionX: canvas.width / 2,\n  positionY: canvas.width / 2,\n  xDirection: 0,\n  yDirection: -1,\n  speed: ballSpeed,\n  color: \"white\",\n  life: 1,\n  toDispose: false,\n};\nprimaryBall.positionY = canvas.height - 80;\n\nballs.push(primaryBall);\n\nlet updateBalls = (deltaTime) => {\n  if (state == \"START\") {\n    //update primary ball\n    balls[0].positionX = paddle.startX + paddle.width * 0.5;\n    balls[0].positionY = paddle.startY - 30;\n  } else {\n    balls.forEach((ball) => updateBall(ball, deltaTime));\n  }\n};\nlet updateBall = (ball, deltaTime) => {\n  ball.positionX += ball.speed * powerSpeed * deltaTime * ball.xDirection;\n  ball.positionY += ball.speed * powerSpeed * deltaTime * ball.yDirection;\n  // if (ball.positionY + ball.radius >= canvas.height) ball.yDirection = -1;\n  if (ball.positionY - ball.radius <= 0)\n    ball.yDirection = Math.abs(ball.yDirection);\n  if (ball.positionX + ball.radius >= canvas.width)\n    ball.xDirection = -Math.abs(ball.xDirection);\n  if (ball.positionX - ball.radius <= 0)\n    ball.xDirection = Math.abs(ball.xDirection);\n\n  //out of bounds\n  if (ball.positionY - ball.radius > canvas.height) {\n    ball.toDispose = true;\n  }\n};\n\nlet drawBalls = () => {\n  balls.forEach((ball) => drawBall(ball));\n};\nlet drawBall = (ball) => {\n  ctx.beginPath();\n  ctx.arc(ball.positionX, ball.positionY, ball.radius, 0, 2 * Math.PI);\n  ctx.fillStyle = ball.color;\n  ctx.fill();\n  // ctx.stroke();\n};\nconst disposeBalls = () => {\n  balls = balls.filter((ball) => !ball.toDispose);\n};\n\nconst checkCollision = () => {\n  //have ball\n  // check every block to see if it is colliding with ball\n  blocks.forEach((block) => {\n    balls.forEach((ball) => {\n      if (isColliding(block, ball)) {\n        let side = calculateCollisionSide(block, ball);\n        if (side == 1) ball.yDirection = 1; //bottom\n        if (side == 2) ball.xDirection = -1; //left\n        if (side == 3) ball.xDirection = 1; //right\n        if (side == 4) ball.yDirection = -1; //top\n        if (block.id != \"paddle\") {\n          activateBlockPower(block);\n          block.toDispose = true;\n          score += 50;\n        } else {\n          //calculate ball angle hitting paddle\n\n          let blockSurface = {\n            start: block.startX,\n            end: block.startX + block.width,\n            center: block.startX + block.width * 0.5,\n          };\n          let frac = ball.positionX - blockSurface.start;\n          let center = blockSurface.center - blockSurface.start;\n          let angle = (frac - center) / block.width;\n          let distanceFromCenter = (frac - center) / block.width;\n          distanceFromCenter = Math.max(-0.3, distanceFromCenter);\n          distanceFromCenter = Math.min(0.3, distanceFromCenter);\n          distanceFromCenter *= 2;\n\n          distanceFromCenter *= 90;\n          distanceFromCenter <= 0\n            ? (distanceFromCenter += 90)\n            : (distanceFromCenter -= 90);\n          // distanceFromCenter = -distanceFromCenter;\n\n          // ball position\n          // convert to angle from 0-180\n          // angle = 180 - (distanceFromCenter + 0.5) * 180;\n          let direction = distanceFromCenter <= 0 ? 1 : -1;\n          let alpha = Math.abs(distanceFromCenter);\n          let c = 1;\n          const alphaRad = (alpha * Math.PI) / 180;\n\n          // Calculate side a\n          const a = c * Math.sin(alphaRad);\n\n          // Calculate side b\n          const b = c * Math.cos(alphaRad);\n\n          // paddle position\n          // normalize or whatever\n          // generate angle with window of tolerance\n          ball.xDirection = b * direction;\n          ball.yDirection = -a;\n        }\n        // ball.speed += 0.005;\n      }\n    });\n  });\n};\nconst isColliding = (block, ball) => {\n  //X intersecting\n  // # Find the closest point on the square\n  let blockCenter = centerOfBlock(block);\n  let blockX = blockCenter.x;\n  let blockY = blockCenter.y;\n  let diff_x = ball.positionX - blockX;\n  let diff_y = ball.positionY - block.startY;\n\n  let closest_x =\n    blockX + Math.max(Math.min(diff_x, block.width / 2), -block.width / 2);\n  let closest_y =\n    blockY + Math.max(Math.min(diff_y, block.height / 2), -block.height / 2);\n\n  // # Calculate the distance\n  let distance = Math.sqrt(\n    (ball.positionX - closest_x) ** 2 + (ball.positionY - closest_y) ** 2\n  );\n  // # Check for collision\n  return distance <= ball.radius;\n};\nconst calculateCollisionSide = (block, ball) => {\n  //lower quadrent\n  // between angle from center of block to lower left angle to andle of block to lower right angle\n  let blockCenter = {\n    x: block.startX + block.width * 0.5,\n    y: block.startY + block.height * 0.5,\n  };\n  let ballAngle = Math.atan2(\n    blockCenter.x - ball.positionX,\n    blockCenter.y - ball.positionY\n  );\n\n  let bottomLeftPosition = { x: block.startX, y: block.startY + block.height };\n  let bottomRightPosition = {\n    x: block.startX + block.width,\n    y: block.startY + block.height,\n  };\n\n  let topLeftPosition = { x: block.startX, y: block.startY };\n  let topRightPosition = {\n    x: block.startX + block.width,\n    y: block.startY,\n  };\n\n  let bottomLeftAngle = Math.atan2(\n    blockCenter.x - bottomLeftPosition.x,\n    blockCenter.y - bottomLeftPosition.y\n  );\n\n  let bottomRightAngle = Math.atan2(\n    blockCenter.x - bottomRightPosition.x,\n    blockCenter.y - bottomRightPosition.y\n  );\n\n  let topLefttAngle = Math.atan2(\n    blockCenter.x - topLeftPosition.x,\n    blockCenter.y - topLeftPosition.y\n  );\n\n  let topRightAngle = Math.atan2(\n    blockCenter.x - topRightPosition.x,\n    blockCenter.y - topRightPosition.y\n  );\n  let angle = 4;\n\n  if (ballAngle > bottomLeftAngle || ballAngle < bottomRightAngle) {\n    // Bottom\n    angle = 1;\n    // block.color = greyBlue;\n  } else if (ballAngle > topLefttAngle && ballAngle < bottomLeftAngle) {\n    // Left\n    angle = 2;\n    // block.color = darkPink;\n  } else if (ballAngle > bottomRightAngle && ballAngle < topRightAngle) {\n    // Right\n    angle = 3;\n    // block.color = darkPink;\n  } else {\n    // Top\n    // block.color = greyBlue;\n  }\n  return angle;\n};\nconst updatePowerups = (deltaTime) => {\n  console.log(\"ball power: \", powerSpeed);\n  powerups = powerups.filter((power) => !power.toDispose);\n  console.log(powerups);\n\n  powerups.forEach((power) => {\n    power.update(deltaTime);\n  });\n};\nclass PowerUp {\n  constructor() {\n    this.toDispose = false;\n  }\n  initPowerUp() {}\n  update(deltaTime) {}\n}\nclass BallSpeedPowerUp extends PowerUp {\n  constructor() {\n    super();\n    this.timeLeft = 5000; //seconds\n    this.initPowerUp();\n  }\n  initPowerUp() {\n    // console.log(\"in init: powerspeed: \", powerSpeed);\n    powerSpeed = 1.35;\n  }\n  update(deltaTime) {\n    this.timeLeft -= deltaTime;\n    // console.log(deltaTime);\n    // console.log(this.timeLeft);\n    if (this.timeLeft <= 0) {\n      console.log(\"disposing\");\n      this.toDispose = true;\n      powerSpeed = 1;\n    }\n  }\n}\nclass PaddleGrowPowerUp extends PowerUp {\n  constructor() {\n    super();\n    this.timeLeft = 5000; //seconds\n    this.initPowerUp();\n  }\n  initPowerUp() {\n    // console.log(\"in init: powerspeed: \", powerSpeed);\n    paddle.width = 250;\n  }\n  update(deltaTime) {\n    this.timeLeft -= deltaTime;\n    // console.log(deltaTime);\n    // console.log(this.timeLeft);\n    if (this.timeLeft <= 0) {\n      this.toDispose = true;\n      paddle.width = 150;\n    }\n  }\n}\n\ndocument.addEventListener(\"keydown\", (e) => {\n  if (e.code === \"ArrowLeft\") {\n    gamePad.left = true;\n  }\n  if (e.code === \"ArrowRight\") {\n    gamePad.right = true;\n  }\n  if (e.code === \"ArrowUp\") {\n    if (state === \"START\") state = \"PLAYING\";\n    gamePad.up = true;\n  }\n  if (e.code === \"KeyR\") {\n    gamePad.reset = true;\n  }\n});\ndocument.addEventListener(\"keyup\", (e) => {\n  if (e.code === \"ArrowLeft\") {\n    gamePad.left = false;\n  }\n  if (e.code === \"ArrowRight\") {\n    gamePad.right = false;\n  }\n  if (e.code === \"ArrowUp\") {\n    gamePad.up = false;\n  }\n\n  if (e.code === \"KeyR\") {\n    gamePad.reset = false;\n  }\n});\n\n// canvas.addEventListener(\"mousemove\", (event) => {\n//   const rect = canvas.getBoundingClientRect(); // Get canvas position relative to viewport\n//   const x = event.clientX - rect.left; // Calculate mouse position relative to canvas\n//   cursorPosX = x - paddle.width * 0.5;\n//   const y = event.clientY - rect.top;\n// });\nconst disposeBlocks = () => {\n  blocks = blocks.filter((block) => !block.toDispose);\n};\nconst updateScore = () => {\n  scoreElement.innerHTML = score;\n};\n\n// const element = document.getElementById(\"yourElement\");\n// let startX, startY;\n\n// document.addEventListener(\"touchstart\", (e) => {\n//   console.log(\"start\");\n//   startX = e.touches[0].clientX;\n//   startY = e.touches[0].clientY;\n//   console.log(startX, startY);\n// });\n\n// document.addEventListener(\"touchmove\", (e) => {\n//   const currentX = e.touches[0].clientX;\n//   const currentY = e.touches[0].clientY;\n\n//   const deltaX = currentX - startX;\n//   const deltaY = currentY - startY;\n//   console.log(currentX, currentY);\n//   // Perform actions based on the drag\n//   // For example, move the element:\n//   // element.style.transform = `translate(${deltaX}px, ${deltaY}px)`;\n// });\n\n// document.addEventListener(\"touchend\", (e) => {\n//   // Actions after drag is completed\n//   // Reset start positions\n//   console.log(\"end\");\n//   startX = 0;\n//   startY = 0;\n// });\n\nlet lastTime = 16;\nlet gameLoop = (currentTime) => {\n  // Calculate deltaTime in milliseconds\n  const deltaTime = currentTime - lastTime;\n\n  if (deltaTime) {\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    checkCollision();\n\n    updatePaddle(deltaTime);\n    updateBlockGroup(deltaTime);\n    updateBalls(deltaTime);\n    updatePowerups(deltaTime);\n    if (state == \"PLAYING\") {\n      titleElement.style.display = \"none\";\n\n      disposeBlocks();\n      disposeBalls();\n\n      if (blocks.length == 1) {\n        // NEXT LEVEL\n        level = level + 1;\n        blockGroup.entering = true;\n        blockGroup.Offset = -400;\n        levelElement.innerHTML = level;\n        createBlocks();\n        // gameOverElement.style.display = \"flex\";\n      }\n      if (balls.length == 0) {\n        if (lives === 0) {\n          state = \"OVER\";\n          gameOverElement.style.display = \"flex\";\n        } else {\n          state = \"START\";\n          lives -= 1;\n          livesElement.innerHTML = lives;\n          balls.push({\n            radius: 15,\n            positionX: paddle.startX + paddle.width * 0.5,\n            positionY: paddle.startY - 30,\n            xDirection: 0,\n            yDirection: -1,\n            speed: ballSpeed,\n            color: \"white\",\n            life: 1,\n            toDispose: false,\n          });\n        }\n      }\n    }\n    if (state == \"OVER\") {\n      if (gamePad.reset) location.reload();\n    }\n\n    // drawPaddle();\n    drawBlocks();\n    drawBalls();\n    updateScore();\n    // Store the current time for the next frame\n    lastTime = currentTime;\n  }\n  requestAnimationFrame(gameLoop);\n};\n\ngameLoop();\n"],"names":["lightPink","darkPink","greyBlue","titleElement","gameOverElement","scoreElement","livesElement","levelElement","score","lives","level","gamePad","paddingTop","canvas","ctx","balls","ballSpeed","powerSpeed","blocks","powerups","state","blockGroup","updateBlockGroup","deltaTime","moveDistance","block","createBlocks","i","j","randomNum","powerNum","color","centerOfBlock","drawBlocks","triangleWidth","activateBlockPower","blockCenter","ball","BallSpeedPowerUp","PaddleGrowPowerUp","paddle","updatePaddle","direction","primaryBall","updateBalls","updateBall","drawBalls","drawBall","disposeBalls","checkCollision","isColliding","side","calculateCollisionSide","blockSurface","frac","center","distanceFromCenter","alpha","c","alphaRad","a","b","blockX","blockY","diff_x","diff_y","closest_x","closest_y","ballAngle","bottomLeftPosition","bottomRightPosition","topLeftPosition","topRightPosition","bottomLeftAngle","bottomRightAngle","topLefttAngle","topRightAngle","angle","updatePowerups","power","PowerUp","e","disposeBlocks","updateScore","lastTime","gameLoop","currentTime"],"mappings":"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"}